'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateSudo = exports.querySudo = undefined;

var _expressHttpContext = require('express-http-context');

var _expressHttpContext2 = _interopRequireDefault(_expressHttpContext);

var _sparqlClient = require('sparql-client-2');

var _envVar = require('env-var');

var _envVar2 = _interopRequireDefault(_envVar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LOG_SPARQL_QUERIES = process.env.LOG_SPARQL_QUERIES != undefined ? _envVar2.default.get('LOG_SPARQL_QUERIES').asBool() : _envVar2.default.get('LOG_SPARQL_ALL').asBool();
var LOG_SPARQL_UPDATES = process.env.LOG_SPARQL_UPDATES != undefined ? _envVar2.default.get('LOG_SPARQL_UPDATES').asBool() : _envVar2.default.get('LOG_SPARQL_ALL').asBool();
var DEBUG_AUTH_HEADERS = _envVar2.default.get('DEBUG_AUTH_HEADERS').asBool();

// The following configuration options are considered optional, but may be overriden as a temporary workaround for issues. Thus, a last resort.
var RETRY = _envVar2.default.get('SUDO_QUERY_RETRY').default('false').asBool();
var RETRY_MAX_ATTEMPTS = _envVar2.default.get('SUDO_QUERY_RETRY_MAX_ATTEMPTS').default('5').asInt();
var RETRY_FOR_HTTP_STATUS_CODES = _envVar2.default.get('SUDO_QUERY_RETRY_FOR_HTTP_STATUS_CODES').default('').asArray();
var RETRY_FOR_CONNECTION_ERRORS = _envVar2.default.get('SUDO_QUERY_RETRY_FOR_CONNECTION_ERRORS').default('ECONNRESET,ETIMEDOUT,EAI_AGAIN').asArray();
var RETRY_TIMEOUT_INCREMENT_FACTOR = _envVar2.default.get('SUDO_QUERY_RETRY_TIMEOUT_INCREMENT_FACTOR').default('0.3').asFloat();

function sudoSparqlClient() {
  var extraHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var connectionOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  var sparqlEndpoint = process.env.MU_SPARQL_ENDPOINT;

  if (connectionOptions) {
    sparqlEndpoint = connectionOptions.sparqlEndpoint || sparqlEndpoint;
  }

  var options = {
    requestDefaults: {
      headers: {
        'mu-auth-sudo': 'true'
      }
    }
  };

  if (_expressHttpContext2.default.get('request')) {
    options.requestDefaults.headers['mu-session-id'] = _expressHttpContext2.default.get('request').get('mu-session-id');
    options.requestDefaults.headers['mu-call-id'] = _expressHttpContext2.default.get('request').get('mu-call-id');
  }

  if (extraHeaders) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.keys(extraHeaders)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        options.requestDefaults.headers[key] = extraHeaders[key];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  if (DEBUG_AUTH_HEADERS) {
    console.log('Headers set on SPARQL client: ' + JSON.stringify(options));
  }

  return new _sparqlClient.SparqlClient(sparqlEndpoint, options);
}

async function executeRawQuery(queryString) {
  var extraHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var connectionOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var attempt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;


  try {

    var response = await sudoSparqlClient(extraHeaders, connectionOptions).query(queryString).executeRaw();
    return maybeParseJSON(response.body);
  } catch (ex) {

    if (mayRetry(ex, attempt, connectionOptions)) {

      attempt += 1;

      var sleepTime = nextAttemptTimeout(attempt);
      console.log('Sleeping ' + sleepTime + ' ms before next attempt');
      await new Promise(function (r) {
        return setTimeout(r, sleepTime);
      });

      return await executeRawQuery(queryString, extraHeaders, connectionOptions, attempt);
    } else {
      console.log('Failed Query:\n                  ' + queryString);
      throw ex;
    }
  }
}

function querySudo(queryString) {
  var extraHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var connectionOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (LOG_SPARQL_QUERIES) {
    console.log(queryString);
  }
  return executeRawQuery(queryString, extraHeaders, connectionOptions);
}

function updateSudo(queryString) {
  var extraHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var connectionOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (LOG_SPARQL_UPDATES) {
    console.log(queryString);
  }
  return executeRawQuery(queryString, extraHeaders, connectionOptions);
}

function maybeParseJSON(body) {
  // Catch invalid JSON
  try {
    return JSON.parse(body);
  } catch (ex) {
    return null;
  }
}

function mayRetry(error, attempt) {
  var connectionOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


  console.log('Checking retry allowed for error: ' + error + ' and attempt: ' + attempt);

  var mayRetry = false;

  if (!(RETRY || connectionOptions.mayRetry)) {
    mayRetry = false;
  } else if (attempt < RETRY_MAX_ATTEMPTS) {
    if (error.code && RETRY_FOR_CONNECTION_ERRORS.includes(error.code)) {
      mayRetry = true;
    } else if (error.httpStatus && RETRY_FOR_HTTP_STATUS_CODES.includes('' + error.httpStatus)) {
      mayRetry = true;
    }
  }

  console.log('Retry allowed? ' + mayRetry);

  return mayRetry;
}

function nextAttemptTimeout(attempt) {
  //expected to be milliseconds
  return Math.round(Math.exp(RETRY_TIMEOUT_INCREMENT_FACTOR * attempt + 10));
}

var _exports = {
  querySudo: querySudo,
  updateSudo: updateSudo
};

exports.default = _exports;
exports.querySudo = querySudo;
exports.updateSudo = updateSudo;